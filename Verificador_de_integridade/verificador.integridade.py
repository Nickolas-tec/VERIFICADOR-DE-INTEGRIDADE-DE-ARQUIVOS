

# ESTE CODIGO CONSTROI UMA FERRAMENTA QUE E CAPAZ DE VERIFICARA INTEGRIDADE E AUTENTICIDADE DE UM ARQUIVO APOS O DOWNLOAD
# UM ARQUIVO BAIXADO DA REDE PODE ESTAR SUJEITO A CORRUPÇÃO DE DADOS DURANTE A TRANSMISSÃO
# A VERIFICAÇÃO DO HASH GARANTE QUE O ARQUIVO ESTEJA INTACTO E NÃO TENHA SIDO ALTERADO. MESMO UMA PEQUENA ALTERAÇÃO NO ARQUIVO
# RESULTARA EM UM VALOR DE HASH COMPLETAMENTE DIFERENTE. ALERTANDO SOBRE POSSIVEIS PROBLEMAS


# ATAQUE MAN - IN - THE - MIDDLE
# O ATAQUE (MITM) E UM TIPO DE ATAQUE AONDE O INVASOR INTERCEPTA E POSSIVELMENTE ALTERA A COMUNICAÇÃO ENTRE DUAS PARTES
# ESTE ATAQUE OCORRE QUANDO O INVASOR SE POSICIONA SECRETAMENTE ENTRE O REMETENTE E O DESTINATARIO DA INFORMAÇÃO


# IMPORTANDO AS BIBLIOTECAS NECESSARIAS
import argparse, hashlib, sys

# ARGPARSE: BIBLIOTECA QUE ANALISA ARGUMENTOS E OPÇÕES DE LINHA DE COMANDO
# HASHLIB: LIVRARIA DE ALGORITMOS SEGUROS DE HASH E RESUMO DE MENSAGENS
# SYS: BIBLIOTECA PARA FORNECER ACESSO A PARAMETROS E FUNÇÕES ESPECIFICAS DO SISTEMA

from colorama import init, Fore

# INICIALIZANDO O COLORAMA PARA ATIVAR O TEXTO COLORIDO DO TERMINAL
init()


# AGORA E CRIADO UMA FUNÇÃO PARA CALCULAR O HASH DO ARQUIVO BAIXADO
# ESSE HASH E O QUE VAMOS USAR PARA COMPARAR COM O HASH QUE OS FORNECEDORES FORNECEM PARA VERIFICAR SE O ARQUIVO E AUTENTICO OU NÃO
def calculate_hash(file_path):
    # CRIANDO UM OBJETO SHA-256
   sha256_hash = hashlib.sha256()
    # ABRA O ARQUIVO EM MODO BINARIO PARA LEITURA
   with open(file_path, "rb") as file:
     # LEIA O ARQUIVO EM PEDAÇÕS DE 64KB PARA LIDAR COM ARQUIVOS GRANDES COM EFICIENCIA
       while True:
           data = file.read(65536) # LEIA O ARQUIVO EM PEDAÇOS DE 64KB 
           if not data:
               break
            # ATUALIZANDO O OBJETO HASH COM OS DADOS LIDOS DO ARQUIVO.
           sha256_hash.update(data)
    # RETORNA A REPRESENTAÇÇÃO HEXADECIMAL DO HASH CALCULADO
   return sha256_hash.hexdigest()


# AGORA CRIAMOS UMA FUNÇAO PARA VERIFICAR O HASH CALCULADO EM RELAÇÃO A UM HASH ESPERADO.
# ESTA FUNÇÃO GARANTE QUE O HASH QUE CALCULAMOS E O HASH ESPERADO. NO ENTANTO, SE O HASH FORNECIDO PELO FORNECEDOR NÃO FOR IGUAL.
# SABEMOS QUE HÁ UM PROBLEMA EM ALGUM LUGAR



def verify_hash(downloaded_file, expected_hash):
   # CALCULE O HASH DO ARQUIVO BAIXADO
   calculated_hash = calculate_hash(downloaded_file)
   # COMPARA O HASH CALCULADO COM O HASH ESPERADO E RETORNE O RESULTADO
   return calculated_hash == expected_hash

# ESTE ALGORITMO E BASEADO EM CLI (COMMAND LINE INTERFACE) ACEITAREMOS A ENTRADA DO USUARIO

# CRIANDO UM ANALISADOR PARA LIDAR COM ARGUMENTOS DE LINHA DE COMANDO
parser = argparse.ArgumentParser(description="Verify the hash of a downloaded software file.")

# DEFINA DOIS ARGUMENTOS DE LINHA DE COMANDO

# -F OU --FILE: CAMINHO PARA O ARQUIVO DO SOFTWARE BAIXADO (OBRIGATORIO)

# --HASH: VALOR DE HASH ESPERADO (OBRIGATORIO)
parser.add_argument("-f", "--file", dest="downloaded_file", required=True, help="Path to the downloaded software file")

parser.add_argument("--hash", dest="expected_hash", required=True, help="Expected hash value")

# ANALISE OS ARGUMENTOS DA LINHA DE COMANDO FORNECIDOS AO EXECUTAR O SCRIPT
args = parser.parse_args()


# VERIFIQUE SE OS ARGUMENTOS DE LINHA DE COMANDO NECESSÁRIOS FORAM FORNECIDOS
if not args.downloaded_file or not args.expected_hash:
   #IMPRIMA UMA MENSAGEM DE ERRO EM VERMELHO USANDO A BIBLIOTECA COLORAMA
   print(f"{Fore.RED}[-] Especifique o arquivo a ser validado e seu Hash.")
   # SAIA DO SCRIPT
   sys.exit()

# O QUE FIZ FOI ADICIONAR SINALIZADORES AOS NOSSOS PROGRAMAS. ASSIM, O USUARIO PODE USAR - F OU --FILE PARA ESPECIFICAR O ARQUIVO A SER VALIDADO
# E --HASH PARA ESPECIFICAR O VALOR HASH ESPERADO DO ARQUIVO.


# VERIFICANDO SE O HASH DO ARQUIVO ESTA CORRETO UTILIZANDO A FUNÇÃO VERIFICA_HASH
if verify_hash(args.downloaded_file, args.expected_hash):
    # SE O HASH ESTIVER CORRETO, IMPRIMA UMA MENSAGEM DE SUCESSO EM VERDE.
   print(f"{Fore.GREEN}[+] Verificação de hash bem-sucedida. O software é autêntico.")
else:
   # SE O HASH NÃO CORRESPONDER IMPRIMA UMA MENSAGEM DE ERRO EM VERMELHO
   print(f"{Fore.RED}[-] A verificação de hash falhou. O software pode ter sido adulterado ou não é autêntico. ​")